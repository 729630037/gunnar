#!/usr/bin/env python
from time import sleep
from sys import stderr

import rospy

from std_msgs.msg import Float32, Int32
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Point, Quaternion, TransformStamped
import tf

import numpy as np

from gunnar.motor import Motor, Encoder



class ResettableRate(rospy.Rate):
    
    def reset(self):
        self.last_time = rospy.rostime.get_rostime()
        
    def remainingSeconds(self):
        return self.remaining().to_sec()
    
    def past(self):
        return self.remainingSeconds() <= 0

    
class Gunnar(object):
    def __init__(self):
        self._spds = [0, 0]
        
        self.robotSpeedsStr = ''
        self.scalingFactor =  0.05
        self.rate = rospy.get_param("rate", 10)
        self.speedSetRate = ResettableRate(self.rate)
        self.motors = [
                       Motor(35, 33, 31),
                       Motor(19, 23, 21),
                       ]
        rospy.loginfo('Set speedSet rate limiter at %s Hz.' % (1./self.speedSetRate.sleep_dur.to_sec(),))
        
        # Initialize encoders and odometer.
        self.encoders = [
                         Encoder(7, 12, 16, backward=True),
                         Encoder(15, 11, 13),
                         ]
        self.odometer = Odometer(*self.encoders)
        
        self.messageEncs = [
                            Int32(),
                            Int32(),
                            ]
#         for m, label in zip(self.messageEncs, ('encl', 'encr')):
#             m.header.frame_id = label
        self.publisherEncs = [
                              rospy.Publisher('/encl', Int32, queue_size=20),
                              rospy.Publisher('/encr', Int32, queue_size=20),
                              ]

    def stop(self):
        self.spds = [0, 0]

    @property
    def spds(self):
        return list(self._spds)

    @spds.setter
    def spds(self, twoList):
        self._spds = list(twoList)
        
        if self.speedSetRate.past():
            changed = False
            for i in 0, 1:
                if twoList[i] != self.spds[i]:
                    ispd = twoList[i] * self.scalingFactor
#                     stderr.write('Setting speed %d to %s.\n' % (i, ispd))
                    self._spds[i] = twoList[i]
                    changed = True
            if changed:
                self.speedSetRate.reset()
                self.robotSpeedsStr = "(%.1f, %.1f)." % tuple(self.spds)

    def updateLidarAngleTf(self):
        if not hasattr(self, 'lidarAngleTfBroadcaster'):
            self.lidarAngleTfBroadcaster = tf.TransformBroadcaster()
        tfb = self.lidarAngleTfBroadcaster
        lidarAngle = self.lidarAngle
        tfb.sendTransform(
            (0, 0, 0),
            tf.transformations.quaternion_from_euler(0, 0, lidarAngle),
            rospy.Time.now(),
            'lidar',
            'base_link',                                   
            )
        
#             <node pkg="tf" type="static_transform_publisher" name="baseLinkToLidarBroadcaster" args="0 0 0 -1.7 0 0 base_link lidar 100">

    @property
    def lidarAngle(self):
        return float(rospy.get_param('lidarAngle', np.pi))
    
    def spinOnce(self):
        for enc, pub, msg in zip(self.encoders, self.publisherEncs, self.messageEncs):
#             msg.header.stamp = rospy.get_rostime()
            msg.data = enc.pos
            pub.publish(msg)
        self.odometer.update()
        self.updateLidarAngleTf()
        
        
class Odometer(object):
    '''Adapted from http://answers.ros.org/question/79851/python-odometry/'''
    
    def __init__(self, encl, encr):
        self.encs = encl, encr
        self.sampLOld = encl.pos
        self.sampROld = encr.pos
        self.theta = 0.0
        self.x = 0.0
        self.y = 0.0
        self.t = self.initTime = rospy.Time.now().to_sec()
    
        self.frame_id = '/odom'
        self.odom_pub = rospy.Publisher('/odom', Odometry, queue_size=10)
        self.tf_broadcaster = tf.TransformBroadcaster()
        self.child_frame_id = '/base_link'

#     CLICKS_PER_M_DEFAULT = (
#         48 * 171.79  # encoder CPR * gear ratio = ticks per wheel revolution
#          / (60. * 2 * np.pi / 1000)  # / meters per revolution
#         )
    CLICKS_PER_M_DEFAULT = 16610.  # experimental
    
    @property
    def RIGHT_CLICKS_PER_M(self):
        return float(rospy.get_param("RIGHT_CLICKS_PER_M", self.CLICKS_PER_M_DEFAULT))
    
    @property
    def LEFT_CLICKS_PER_M(self):
        return float(rospy.get_param("LEFT_CLICKS_PER_M", self.CLICKS_PER_M_DEFAULT))
    
    @property
    def WHEEL_BASE_M(self):
        return float(rospy.get_param("WHEEL_BASE_M", 0.3177))
      
    def publish_odom(self, xyz, thxyz, vxyz, vthxyz):
        
        # Initialize Odometry message object.
        msg = Odometry()
        msg.header.stamp = rospy.Time.now()
        msg.header.frame_id = self.frame_id # i.e. '/odom'
        msg.child_frame_id = self.child_frame_id # i.e. '/base_footprint'
        
        # Fill the messages with data.
        msg.pose.pose.position = Point(*xyz)
        quat = tf.transformations.quaternion_from_euler(*thxyz)
        msg.pose.pose.orientation = Quaternion(*quat)
        
        for i in range(3):
            setattr(msg.twist.twist.linear, 'xyz'[i], vxyz[i])
            setattr(msg.twist.twist.angular, 'xyz'[i], vthxyz[i])
            
        self.tf_broadcaster.sendTransform(
            xyz,
            quat,
            msg.header.stamp,
            self.child_frame_id,
            self.frame_id,
            )
        
        # position covariance
        P = np.mat(np.diag([0.0]*3))  # Covariance
        p_cov = np.array([0.0]*36).reshape(6,6)
        p_cov[0:2,0:2] = P[0:2,0:2]
        # orientation covariance for Yaw
        # x and Yaw
        p_cov[5,0] = p_cov[0,5] = P[2,0]
        # y and Yaw
        p_cov[5,1] = p_cov[1,5] = P[2,1]
        # Yaw and Yaw
        p_cov[5,5] = P[2,2]
  
        msg.pose.covariance = tuple(p_cov.ravel().tolist())
  
        # Publish odometry message
        self.odom_pub.publish(msg)
  
    def update(self):
        '''Sample encoders and publish odometry topic and tf.
        
        Adapted from
            http://www.seattlerobotics.org/encoder/200610/Article3/IMU%20Odometry,%20by%20David%20Anderson.htm
            https://www.cs.princeton.edu/courses/archive/fall11/cos495/COS495-Lecture5-Odometry.pdf
            
        '''
        from math import cos, sin
        
        #### DETERMINE ARC MOVEMENTS #### 
        # Sample the left and right encoder counts as close together
        # in time as possible.
        sampL, sampR = [enc.pos for enc in self.encs]
        oldt = self.t
        self.t = rospy.Time.now().to_sec()
        dt = self.t - oldt

        # Determine how many ticks have passed since our last sampling.
        dTicksL = sampL - self.sampLOld
        dTicksR = sampR - self.sampROld
        self.sampLOld = sampL
        self.sampROld = sampR

        # Convert longs to floats and ticks to meters.
        deltaSlMeters = float(dTicksL) / self.LEFT_CLICKS_PER_M
        deltaSrMeters = float(dTicksR) / self.RIGHT_CLICKS_PER_M

        # Calculate central distance we have traveled since last sampling.
        deltaSMeters = (deltaSrMeters + deltaSlMeters) / 2.0
    
        # Accumulate total rotation around our center (radians).
        # Subtracting L from R gives us a right-handed coordinate system?
        deltaTheta = (deltaSlMeters - deltaSrMeters) / self.WHEEL_BASE_M
        self.theta += deltaTheta
        
        # Accumulate our translation from the odometry frame (meters).
        deltaX = deltaSMeters * cos(self.theta + deltaTheta / 2.)
        deltaY = deltaSMeters * sin(self.theta + deltaTheta / 2.)
        self.x += deltaX
        self.y += deltaY 

        translationRates = (
            deltaX / dt,
            deltaY / dt,
            0.0,
            )
        rotationRates = (
            0.0,
            0.0,
            deltaTheta / dt,
            )

        self.publish_odom(
            (self.x, self.y, 0),
            (0, 0, self.theta),
            translationRates,
            rotationRates)
        

class VtargetListener(Gunnar):
    
    def __init__(self):
        rospy.init_node('hardware_driver', log_level=rospy.DEBUG)
        super(VtargetListener, self).__init__()
        rospy.loginfo('Begin VtargetListener init.')
        rospy.Subscriber('/lwheel_vtarget', Float32, self.lwheelCallback)
        rospy.Subscriber('/rwheel_vtarget', Float32, self.rwheelCallback)
        rospy.loginfo('Done with VtargetListener init.')
        print 'Done with VtargetListener init.'
        
    def lwheelCallback(self, data):
        self.spds = [data.data, self.spds[1]]
        self.motors[0].setFrac(data.data * self.scalingFactor)
        
    def rwheelCallback(self, data):
        self.spds = [self.spds[0], data.data]
        self.motors[1].setFrac(data.data * self.scalingFactor)
        
    def spin(self):
        r = rospy.Rate(self.rate)
        idle = rospy.Rate(10)
        while not rospy.is_shutdown():
            # Time per loop iteration will be max(ts, tr, ti), where ts, tr,
            # and ti are the duration of the spin code, rate period, and idle
            # period, respectively. That is, the period will strive to match the
            # slower of the two Rates, but might be a longer if the spin takes
            # longer.
            #
            # This doesn't clarify why an idle is useful, rather than just using
            # a slower rate.
            self.spinOnce()
            r.sleep()
            idle.sleep()


def main():
    listener = VtargetListener()
    listener.spin()

if __name__ == "__main__":
    main()

