#!/usr/bin/env python
from time import sleep
from sys import stderr
# def writeErr(s, endl=True):
#     stderr.write(s)
#     if endl:
#         stderr.write('\n')

# from sys import path
# # from os.path import dirname
# # from sys import argv 
# # writeErr('')
# # thisDir = dirname(argv[0])
# # writeErr('This script is in %s.' % thisDir)
# # 
# # path.append(thisDir + '/../src')
# 
# writeErr("PYTHONPATH is:")
# for p in path:
#     writeErr('  %s' % p)

from gunnar.motor import Motor
from std_msgs.msg import Float32

import rospy


class ResettableRate(rospy.Rate):
    
    def reset(self):
        self.last_time = rospy.rostime.get_rostime()
        
    def remainingSeconds(self):
        return self.remaining().to_sec()
    
    def past(self):
        return self.remainingSeconds() <= 0


class Gunnar(object):
    def __init__(self):
        self._spds = [0, 0]
        self.robotSpeedsStr = ''
        self.rate = rospy.get_param("~rate", 10)
        self.speedSetRate = ResettableRate(self.rate)
        self.motors = [
                       Motor(35, 33, 31),
                       Motor(19, 23, 21),
                       ]
        rospy.loginfo('Set speedSet rate limiter at %s Hz.' % (1./self.speedSetRate.sleep_dur.to_sec(),))

    def stop(self):
        self.spds = [0, 0]

    @property
    def spds(self):
        return list(self._spds)

    @spds.setter
    def spds(self, twoList):
        if self.speedSetRate.past():
            changed = False
            for i in 0, 1:
                if twoList[i] != self.spds[i]:
#                     writeErr('Set motor %d speed frac to %f.' % (i, twoList[i],))
                    self.motors[i].setFrac(twoList[i] / 100.)
                    self._spds[i] = twoList[i]
                    changed = True
            if changed:
                self.speedSetRate.reset()
                self.robotSpeedsStr = "(%.1f, %.1f)." % tuple(self.spds)
#                 writeErr('Motor speeds were modified to %s.' % self.robotSpeedsStr)

#     def cmdSetSpeeds(self, a, b):
#         self.communicator.speedSet(a, b)
#         self.robotSpeedsStr = "(%.1f, %.1f)." % (a, b)

    def spinOnce(self):
        pass


class VtargetListener(Gunnar):
    
    def __init__(self):
        rospy.init_node('hardware_driver', log_level=rospy.DEBUG)
        super(VtargetListener, self).__init__()
        rospy.loginfo('Begin VtargetListener init.')
        rospy.Subscriber('/lwheel_vtarget', Float32, self.lwheelCallback)
        rospy.Subscriber('/rwheel_vtarget', Float32, self.rwheelCallback)
        rospy.loginfo('Done with VtargetListener init.')
        print 'Done with VtargetListener init.'
        
#     def lwheelCallback(self, data):
#         self.motors[0].setFrac(data.data)
        
    def lwheelCallback(self, data):
#         rospy.logdebug('got left wheel data %s' % data.data)
        self.spds = [data.data, self.spds[1]]
        
    def rwheelCallback(self, data):
#         rospy.logdebug('got right wheel data %s' % data.data)
        self.spds = [self.spds[0], data.data]
        
    def spin(self):
        r = rospy.Rate(self.rate)
        idle = rospy.Rate(10)
        while not rospy.is_shutdown():
            # Time per loop iteration will be max(ts, tr, ti), where ts, tr,
            # and ti are the duration of the spin code, rate period, and idle
            # period, respectively. That is, the period will strive to match the
            # slower of the two Rates, but might be a longer if the spin takes
            # longer.
            #
            # This doesn't clarify why an idle is useful, rather than just using
            # a slower rate.
            self.spinOnce()
            r.sleep()
            idle.sleep()


def main():
    listener = VtargetListener()
    listener.spin()

if __name__ == "__main__":
    main()

